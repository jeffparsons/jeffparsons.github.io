---
layout:     post
title:      "These weeks in PlanetKit #6: the joy of motion"
date:       2000-01-01
summary:    Moving entities around a geodesic grid.
tags:       rust planetkit geodesic
published:  false
---

PlanetKit is a project aimed at creating a toolkit for making interactive virtual worlds. I'm writing it in the Rust programming language, which I'm finding delightful to work with, and a great fit for the task.

This week I'm going to figure out how to move entities around between cells in my voxel world. The simple case is actually really easy (I'm effectively already doing it in generating geometry for the world), but the various edge cases add up to make it an interesting problem in the general case.

Here are my minimal criteria:

- Entities can face any one of the six sides of an ordinary (hexagonal) cell; or, equivalently, entities can face the center of any immediately adjacent cell. This must also be true at each of the 12 pentagons.
- Moving _k_ steps forward and then _k_ steps backwards will return an entity to its original cell, with its original orientation.
- Moving across boundaries between root quads must translate the entity's original orientation into something equivalent in the adjacent quad. Crossing at a pentagon must at least do something consistent with these other criteria.

I'll justify and elaborate on each of these below.


## Basic orientation

From above, _"entities can face any one of the six sides of an ordinary (hexagonal) cell; or, equivalently, entities can face the center of any immediately adjacent cell."_

Well, that seems straightforward enough. We'll just number the orientations from 0 through 5 like so:

{% highlight plaintext %}
         \     3     /
          \         /
           ●-------●
      4   /         \   2
         /           \
        /             \
  -----●       ◌       ●-----
        \             /
         \           /
      5   \         /   1
           ●-------●
          /         \
         /     0     \

               x
               ↓
{% endhighlight %}

However, _"this must also be true at each of the 12 pentagons"_.

If I stick with numbering orientations from 0 through 5 then I have to decide which side a pentagon is missing. Let's take a look at a slice of the pentagon at the north pole, for example:

{% highlight plaintext %}
●
|`~.
|   `~●
|    / `~.
●---●     `~◌
|    \       `~.
|     \         `~◌
|      \         / `~.
◌       ◌-------◌     `~◌
|      /         \      |  y
|     /           \     |   ↘
|    /             \    |
◌---◌       ◌       ◌---◌
|    \             /    |
|     \           /     |
|      \         /      |
◌       ◌-------◌       ◌
 `~.   /         \      |
    `~◌           \     |
x      `~.         \    |
↓         `~◌       ◌---◌
             `~.   /    |
                `~◌     |
                   `~.  |
                      `~◌
{% endhighlight %}

From here it's pretty obvious to me that the pentagon at _(0, 0)_ has at least sides 0 (positive x direction) and 1 (positive y direction). But beyond that we'd be pointing off into other root quads, and it's not clear to me what that would mean. For example, the opposite of direction 0 would normally be direction 3, but on a pentagon, there is a vertex opposite a side, _not_ another side! (This may be more clear from the first picture on [this page](http://kiwi.atmos.colostate.edu/BUGS/geodesic/text.html).)

What if we approach this differently? Instead of just numbering sides, we could also include the vertices in our numbering scheme. Then we can at least represent the idea that in a pentagon there is a vertex opposite each side, and figure out the math for that a little bit later.

Our numbering on ordinary (hexagonal) cells now looks like this:

{% highlight plaintext %}
        7             5
               6
          \         /
           ●-------●
      8   /         \   4
         /           \
        /             \
  9  --●       ◌       ●--  3
        \             /
         \           /
     10   \         /   2
           ●-------●
          /         \
               0
       11             1
               x
               ↓
{% endhighlight %}

Note that none of this prevents us from enforcing that entities can only face adjacent cells. We could, for example, always rotate the entity a tiny bit anti-clockwise if it ends up facing an illegal direction at the end of a step. But my gut tells me that this is all going to be a lot neater if we represent all 12 directions so that we can ignore the "only facing adjacent cells" rule across multiple intermediate states, and then clean it up at the very end as a single operation.
