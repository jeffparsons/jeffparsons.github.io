---
layout:     post
title:      "These weeks in PlanetKit #6: the joy of motion"
date:       2000-01-01
summary:    Moving entities around a geodesic grid.
tags:       rust planetkit geodesic
published:  false
---

PlanetKit is a project aimed at creating a toolkit for making interactive virtual worlds. I'm writing it in the Rust programming language, which I'm finding delightful to work with, and a great fit for the task.

This week I'm going to figure out how to step entities around between cells in my voxel world.

<video src="/videos/walking-in-circles-low.mp4" autoplay loop>
    Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href="/videos/walking-in-circles-low.mp4">download it</a> and watch it with your favorite video player!
</video>


## Why is this a problem?

Maybe it is actually trivial, and I'm just missing some key simplifying insight. But let's pretend for now that I'm right, and it is legitimately a nontrivial problem.

Recall that the coordinate system in my world consists of 5 "root quads" wrapped around a sphere. Within each quad I use an axial coordinate system. (Scroll down a bit on [this great Red Blob Games article](http://www.redblobgames.com/grids/hexagons/#coordinates) for an explanation.)

I've highlighted all the hexagons in one of the root quads below. (Yes, those filled circles are hexagons. Try to suspend disbelief.)

{% highlight plaintext %}
     ●     ◌     ◌     ◌     ◌
    ● ●   / \   / \   / \   / \
   ● ● ● /   \ /   \ /   \ /   \
  ● ● ● ●     ◌     ◌     ◌     ◌
   ● ● ● ●     \     \     \     \
    ● ● ● ●     \     \     \     \
     ● ● ● ●     ◌     ◌     ◌     ◌
      ● ● ● \   / \   / \   / \   /
       ● ●   \ /   \ /   \ /   \ /
        ●     ◌     ◌     ◌     ◌
{% endhighlight %}

If we consider a single root quad in isolation, then all we need is a tiny bit of modular arithmetic for turning to face each of a hexagonal cell's six neighbors, and a similarly tiny lookup table for the _(x, y)_ offsets of each neighbor.

If we number hexagonal cell edges from 0 through 5, then the _(x, y)_ offsets to reach each neighbouring hexagon are:

{% highlight plaintext %}
          (-1, 0)
       \     3     /
        \         /
(0, -1)  ●-------●      (-1, +1)
   4    /         \   2
       /           \
      /             \
-----●       ◌       ●-----
      \             /
       \           /
    5   \         /   1
(+1, -1) ●-------●      (0, +1)
        /         \
       /     0     \          y
          (+1, 0)              ↘

             x
             ↓
{% endhighlight %}

That'd be about 15 lines of code all told. Simple.

Unfortunately we have a few complications to address on account of our world being a globe rather than a flat earth:

- The world is not one giant coordinate space. There are five separate coordinate spaces that connect along various edges.
- Orientation _r_ is often not the same in one quad as in its neighbor. Look at the net above and imagine how it folds into a sphere. Quads to the left and right at the north and south poles have their coordinate systems rotated with respect to each other. This is even more extreme when _crossing_ the north or south poles.
- Our world isn't just hexagons. There are also 12 pentagons, and so moving through a pentagon isn't as simple as entering through one side, and then leaving through the opposite side -- in a pentagon, it's a _vertex_ opposite each side! Further to this, if you're sitting on a pentagon, which of the six hexagon edges is it "missing"? 0? 5? One of the edges between those?

So I've created quite the mess for myself.


## What do we need?

Before diving into implementing a solution, I need to nail down a list of minimal criteria that any solution must meet. Here's what I came up with:

- Entities can face towards the center of any immediately adjacent cell. For hexagonal cells, this means that they can face any of the six edges of the current cell. For each of the 12 pentagonal cells, it's five edges.
- Any movement or turning must result in facing a valid direction for further movement -- i.e. toward an immediately neighboring cell, not toward a vertex between two neighbors.
- Moving _k_ steps forward and then _k_ steps backwards will return an entity to its original cell, with its original orientation.
- Moving across boundaries between root quads must translate the entity's original orientation into something equivalent in the adjacent quad. Crossing at a pentagon must at least do something consistent with these other criteria.

And my bonus criterion, which I think can be achieved easily enough once the others are met:

- If last time you moved into a pentagon you were reoriented to the side slightly left of where you were originally facing, then the next time you will be reoriented slightly right, and vice versa. This isn't really important, but feels nice to me for balance.

I'll justify and elaborate on each of these below.


TODO: most of the stuff from here isn't quite what you want to express. Probably ditch most of it.



## Basic orientation

From above, _"entities can face towards the center of any immediately adjacent cell. For hexagonal cells, this means that they can face any of the six edges of the current cell."_

Well, that seems straightforward enough. We'll just number the orientations from 0 through 5 like so:

{% highlight plaintext %}
         \     3     /
          \         /
           ●-------●
      4   /         \   2
         /           \
        /             \
  -----●       ◌       ●-----
        \             /
         \           /
      5   \         /   1
           ●-------●
          /         \
         /     0     \

               x
               ↓
{% endhighlight %}

However, _"for each of the 12 pentagonal cells, it's five edges"_.


TODO: replace lots of this with the better justification for 12 directions: we sometimes want to represent the directions that are invalid to move towards.



If I stick with numbering orientations from 0 through 5 then I have to decide which of the six nominal sides a pentagon is "missing". Let's take a look at a slice of the pentagon at the north pole, for example:

{% highlight plaintext %}
●
|`~.
|...`~●
|..../ `~.
●---●     `~◌
|    \       `~.
|     \         `~◌
|      \         / `~.
◌       ◌-------◌     `~◌
|      /         \      |  y
|     /           \     |   ↘
|    /             \    |
◌---◌       ◌       ◌---◌
|    \             /    |
|     \           /     |
|      \         /      |
◌       ◌-------◌       ◌
 `~.   /         \      |
    `~◌           \     |
x      `~.         \    |
↓         `~◌       ◌---◌
             `~.   /    |
                `~◌     |
                   `~.  |
                      `~◌
{% endhighlight %}

From here it's pretty obvious to me that the pentagon at _(0, 0)_ has at least sides 0 (positive x direction) and 1 (positive y direction). But beyond that we'd be pointing off into other root quads, and it's not clear to me what that would mean. For example, the opposite of direction 0 would normally be direction 3, but on a pentagon, there is a vertex opposite a side, _not_ another side! (This may be more clear from the first picture on [this page](http://kiwi.atmos.colostate.edu/BUGS/geodesic/text.html).)

What if we approach this differently? Instead of just numbering sides, we could also include the vertices in our numbering scheme. Then we can at least represent the idea that in a pentagon there is a vertex opposite each side, and figure out the math for that a little bit later.

Our numbering on ordinary (hexagonal) cells now looks like this:

{% highlight plaintext %}
        7             5
               6
          \         /
           ●-------●
      8   /         \   4
         /           \
        /             \
  9  --●       ◌       ●--  3
        \             /
         \           /
     10   \         /   2
           ●-------●
          /         \
               0
       11             1
               x
               ↓
{% endhighlight %}

Note that none of this prevents us from enforcing that entities can only face adjacent cells. We could, for example, always rotate the entity a tiny bit anti-clockwise if it ends up facing an illegal direction at the end of a step. But my gut tells me that this is all going to be a lot neater if we represent all 12 directions so that we can ignore the "only facing adjacent cells" rule across multiple intermediate states, and then clean it up at the very end as a single operation.


## Criterion 1: ...?


## Solution

- Always transform to arctic triangle first.
- Handle the cases there...
- Transform back.


## Testing

- Unit testing
- "Fuzz testing"


## Screenshots?



## Video?
