---
layout:     post
title:      "These weeks in PlanetKit #7: changing the world, one block at a time"
date:       2017-01-26
summary:    Dynamically regenerating chunk meshes, and fighting the borrow-checker.
tags:       rust planetkit geodesic
published:  false
---

PlanetKit is a project aimed at creating a toolkit for making interactive virtual worlds. I'm writing it in the Rust programming language, which I'm finding delightful to work with, and a great fit for the task.

This week I'm going to allow the player to remove blocks from my voxel world.

<video src="/videos/mining-low.mp4" autoplay loop>
    Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href="/videos/mining-low.mp4">download it</a> and watch it with your favorite video player!
</video>

Yes, it's getting a bit tedious to look at that same scene. I'm planning to freshen it up a bit before my next post, with things like a much larger world, and a new random seed each time.


## Movement follow-up

Before I got around to implementing the actual world mutation stuff, I figured I'd better follow up on the basic motion. You may have noticed in my last post (todo: link) that I kinda glossed over how movement interacts with the terrain. That's because I didn't do anything on that. You could just walk into the ground, and wander around inside the planet.

So before I started making it so you can modify the world, I quickly made amends.

This involved implementing the following rules:

- Deny attempts to move into terrain
- Disallow movement if there's no ground beneath you.
- Allow stepping up one block if there's not one in front of you

And one final piece: gravity. Gravity is just another system that currently affects all CellDwellers. As things become more complex, I'll either have a separate component types for celldwellers affected by gravity or, because that's probably over-abstracting things, just allow setting a boolean flag for whether a cell dweller entity is affected by gravity.


## Dynamic chunk creation

First step was to implement dynamic chunk creation. Here's what the world looks like now when you start it.

<video src="/videos/chunk-mesh-creation-log.mp4" autoplay loop>
    Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href="/videos/chunk-mesh-creation-log.mp4">download it</a> and watch it with your favorite video player!
</video>

Note that this is only slow to update because I deliberately impose a limit on how many chunk meshes I will generate per second, to prevent it from having a noticeable impact on gameplay. This is in anticipation of needing to regularly regenerate chunk meshes during play.

In future I'll ameliorate the effect by adding a priority system whereby chunks closer to the player have their meshes generated first, and probably also add a loading period at the start of a level where at least a decent chunk of the chunks have their meshes created before you see anything.

Now. Implementation details. I'm trying to embrace the ECS model, so I just made another system responsible for creating chunk meshes when there's either no mesh made yet, or when it is out-of-date with the current chunk data.

I fairly quickly ran into a problem: I can't actually make the VBOs etc for the mesh in my system or the render system, because:

- Implementors of the Specs ECS [`System`](https://slide-rs.github.io/specs/specs/trait.System.html) trait must be `Send`.
- [gfx OpenGL resource `Factory`](https://docs.rs/gfx_device_gl/0.13.0/gfx_device_gl/struct.Factory.html) is not `Send`.

The consequence is that all video card resource creation must happen on the device thread (in my case, the main thread).

Solution:

Split out a "mesh repository" to be shared as a `Arc<Mutex<MeshRepository>>` by all the relevant systems, that contains both video card VBO mesh handles, and also _proto-meshes_. Proto-meshes contain all the information required to build a mesh on the video card side based on my PSOs (vertices, vertex incides, etc.).

Then on each frame on the main thread I reify any proto-meshes into video card VBOs etc.


## Actually mining for reals!

My initial pass on this was a very simple system, similar to the movement system, that allows removing dirt blocks in front of you. This was trivial to get up and running with a couple of minutes of copy+pasta.

But this doesn't let you see the changes you've made. So I needed to start regenerating chunk meshes when the chunk contents changes. Pretty easy, except that this now requires me to copy updates to chunks into their neighbouring chunks if those neighbours share an edge, but the neighbour doesn't own the edge. Otherwise we'll just update one chunk mesh when we remove a block and it'll only look like half of it goes away.

So I made all chunks build a list of their neighbour chunk locations when created, and used that to update dirty chunks.

And that's when I ran into borrowck woes. Which surprised me, because things have actually been pretty cruisy between me and borrowck up until now. It's usually just been pointing out to me that what I'm trying to achieve is actually wrong, and I need to amend my ways.

Borrowing parts of a chunk to find what other chunks you should be mutating in the same array, and then copying data between them, means complications. And especially so given that I couldn't just fall back to using `RefCell`s, because this is all happening in a struct that implements `Component` (https://slide-rs.github.io/specs/specs/trait.Component.html)... oh my, did you misread the docs? Maybe you could have just used `RefCell`s.

I'm not going to try to hide my warts. Here's the function as it currently stands on `master`:

// TODO: this is a bit much; probably don't actually include it in full.

{% highlight rust %}
fn maybe_copy_authoritative_cells(&mut self, target_chunk_origin: CellPos) {
    let target_chunk_index = match self.index_of_chunk_at(target_chunk_origin) {
        None => {
            // No worries; the chunk isn't loaded. Do nothing.
            return;
        },
        Some(target_chunk_index) => target_chunk_index,
    };

    // BEWARE: MULTIPLE HACKS BELOW to get around borrowck. There has to be
    // a better way around this!

    // Temporarily remove the target chunk from the globe,
    // so that we can simultaneously write to it and read from
    // a bunch of other chunks.
    //
    // TODO: at very least avoid this most of the time by doing a read-only pass over
    // all neighbours and bailing out if we're completely up-to-date.
    let mut target_chunk = self.chunks.swap_remove(target_chunk_index);

    // Temporarily remove list of neighbours from target chunk
    // so that we can simultaneously read from it and update
    // the chunk's data.
    let mut neighbors = Vec::<super::chunk::Neighbor>::new();
    use std::mem::swap;
    swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

    // For each of this chunk's neighbors, see if we have up-to-date
    // copies of the data we share with that neighbor. Otherwise,
    // copy it over.
    for neighbor in &mut neighbors {
        let source_chunk_index = match self.index_of_chunk_at(neighbor.origin) {
            None => {
                // No worries; the chunk isn't loaded. Do nothing.
                continue;
            },
            Some(source_chunk_index) => source_chunk_index,
        };

        let source_chunk = &self.chunks[source_chunk_index];
        if neighbor.last_known_version == source_chunk.version {
            // We're already up-to-date with this neighbor's data; skip.
            continue;
        }

        // Copy over each cell, one by one.
        for target_cell_pos in &neighbor.shared_cells {
            let source_cell_pos = pos_in_owning_root(*target_cell_pos, self.spec.root_resolution);
            let source_cell =
                *source_chunk.cell(source_cell_pos);
            let target_cell =
                target_chunk.cell_mut(*target_cell_pos);
            // Copy source -> target.
            *target_cell = source_cell;
        }

        // We're now up-to-date with the neighbor.
        neighbor.last_known_version = source_chunk.version;

        // If we got this far, then it means we needed to update something.
        // So mark this chunk as having its view out-of-date.
        //
        // TODO: this all lacks subtlety; we only actually need to update the
        // destination chunk's data if the dirty cell was on the edge of
        // the chunk. This needs some thought on a good interface for mutating
        // chunks that doesn't allow oopsing this...
        target_chunk.mark_view_as_dirty();
    }

    // Put the list of neighbors back into the chunk.
    swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

    // Put the target chunk back into the world!
    self.chunks.push(target_chunk);
}
{% endhighlight %}

Note in particular: Temporarily removing the target chunk from the globe, so that we can simultaneously write to it and read from a bunch of other chunks via the chunks vector, and then putting it back into that vector at the end...

{% highlight rust %}
let mut target_chunk = self.chunks.swap_remove(target_chunk_index);

// ...

self.chunks.push(target_chunk);
{% endhighlight %}

And then between those, because I want to be able to mutate the chunk through its own functions while also iterating over a list of its neighbours, temporarily remove the list of neighbours from the struct and put it back at the end:

{% highlight rust %}
let mut neighbors = Vec::<super::chunk::Neighbor>::new();
use std::mem::swap;
swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

// ...

swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);
{% endhighlight %}

Yuck!

Ok, TODO: check out the `RefCell` approach.

What I really want, is to be able to avoid redundant index operations by doing something like https://github.com/golddranks/multi_mut provides, once the dust settles on all that undefined behaviour debate.


## What's next?

TODO:

- adding more types


As always, the source for everything I'm talking about here is up in the [_planetkit_ repository on GitHub](https://github.com/jeffparsons/planetkit).
