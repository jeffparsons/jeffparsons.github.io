---
layout:     post
title:      "These weeks in PlanetKit #7: changing the world, one block at a time"
date:       2017-01-26
summary:    Dynamically regenerating chunk meshes, and fighting the borrow-checker.
tags:       rust planetkit geodesic
published:  false
---

PlanetKit is a project aimed at creating a toolkit for making interactive virtual worlds. I'm writing it in the Rust programming language, which I'm finding delightful to work with, and a great fit for the task.

This week I'm going to allow the player to remove blocks from my voxel world.

<video src="/videos/mining-low.mp4" autoplay loop>
    Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href="/videos/mining-low.mp4">download it</a> and watch it with your favorite video player!
</video>

Yes, I realise as I write this that it's getting a bit tedious to look at that same scene. I'm planning to freshen it up a bit before my next post, with things like a much larger world, and a new random seed each time. But the way I'm taking videos right now is really painful, so I'm not prepared to re-make them right now for this post.


## Movement follow-up

Before I built the bits that let you modify the world, I figured I'd better follow up on the half-baked movement system from [last time]({% post_url 2016-12-30-movement %}). You may have noticed if you read it that I kind of glossed over how movement interacts with the terrain. And that would be because it... doesn't. You could just walk into the ground, and wander inside the planet.

So before I started making it so you can modify the world, I quickly made amends.

This involved implementing the following rules:

- Reject attempt if there is terrain where you're trying to move.
- Reject attempt if there is no ground beneath you, to stop you from skipping over gaps by moving quickly across them when you should fall into them.
- If there's ground where you're trying to move to, then look one block above it, and try again. This lets you step up hills by at most one block.

And one final piece: gravity. I've implemented gravity simply as another `System` that affects all `CellDweller`s, rather than creating a new component type for things affected by gravity. I can see an argument for making each component handle as little as possible, but for now I'm going to err on the side of treating gravity as a common enough behaviour that it doesn't hurt to assume all `CellDweller`s are at least potentially affected by it.


## Dynamic chunk creation

First step was to implement dynamic chunk creation. Here's what the demo app looks like now when you start it.

<video src="/videos/chunk-mesh-creation-low.mp4" autoplay loop>
    Sorry, your browser doesn't support embedded videos, but don't worry, you can <a href="/videos/chunk-mesh-creation-low.mp4">download it</a> and watch it with your favorite video player!
</video>

Note that this is only slow to update because I've deliberately imposed a limit on how many chunk meshes I will generate per second. My purpose here is to prevent chunk mesh generation from having a noticeable impact on gameplay, no matter how many chunks need to be regenerated. This is in anticipation of having very frequent updates to terrain in, say, a multi-player arena shooter.

In future I'll ameliorate the overly-conservative slow loading by adding a priority system whereby chunks closer to the player have their meshes generated first, and probably some kind of time budget per frame to be spent on generating chunk meshes, rather than limiting it strictly to at most one chunk per frame as it is now.

Now for some implementation details. I'm trying to embrace the [Entity–component–system paradigm](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system), so I made another `System` responsible for creating a mesh for a chunk when there's either no mesh made yet, or when there is a mesh but it is out-of-date with the current chunk data.

I fairly quickly ran into a problem: I can't actually make the [VBOs](https://en.wikipedia.org/wiki/Vertex_Buffer_Object) and other video card resources for the mesh in my new `System` or in the render `System`, because:

- Implementors of the Specs [`System` trait](https://slide-rs.github.io/specs/specs/trait.System.html) must be `Send`.
- The [gfx OpenGL resource `Factory`](https://docs.rs/gfx_device_gl/0.13.0/gfx_device_gl/struct.Factory.html) is _not_ `Send`.

The consequence is that all video card resource creation must happen on the device thread --- in my case, the main thread.

My solution:

Split out a "mesh repository", containing both video card resource handles and also _proto-meshes_ that contain all the information required to build those video card resources. This is then shared via an `Arc<Mutex<MeshRepository>>` by all the systems that need it.

Then any system that wants can create new proto-meshes, and in each frame on the main thread I reify any proto-meshes into video card VBOs and friends. This is plenty quick enough as long as I'm throttling the creation of proto-meshes elsewhere.


## Actually mining for realsies!

My initial pass on this is a very simple system that's been able to re-use much of the work I already did to handle movement. It lets you removing dirt blocks in front of you. Neato! This was trivial to get up and running with a couple of minutes of copy, paste, hack.

But this alone doesn't let you see the changes you've made. So I needed to start regenerating chunk meshes when the chunk contents changes. That's pretty easy in theory, except that this now also requires me to copy updates to chunks into their neighbouring chunks whenever the first chunk is the source of truth for the cells along the edge with said neighbor. Otherwise we'll just update one chunk mesh when we remove a block on an edge between chunks and it'll only look like half of it goes away. (I go into some detail about sharing of cells along chunk boundaries in a [previous post]({% post_url 2016-11-18-fix-cracks %}).)

So I made all chunks build a list of their neighbor chunk locations when created, and used that to update dirty chunks.

And that's when I ran into borrow checker woes. Which surprised me, because things have actually been pretty cruisy between me and the compiler up until now. Usually whenever we fight, I pretty quickly concede that Rust is just pointing out to me that what I'm trying to achieve is actually wrong, and I need to amend my wicked ways.

TODO: clean up from here

Borrowing parts of a chunk to find what other chunks you should be mutating in the same array, and then copying data between them, means complications. And especially so given that I couldn't just fall back to using `RefCell`s, because this is all happening in a struct that implements `Component` (https://slide-rs.github.io/specs/specs/trait.Component.html)... oh my, did you misread the docs? Maybe you could have just used `RefCell`s.

I'm not going to try to hide my warts. Here's the function as it currently stands on `master`:

// TODO: this is a bit much; probably don't actually include it in full.

{% highlight rust %}
fn maybe_copy_authoritative_cells(&mut self, target_chunk_origin: CellPos) {
    let target_chunk_index = match self.index_of_chunk_at(target_chunk_origin) {
        None => {
            // No worries; the chunk isn't loaded. Do nothing.
            return;
        },
        Some(target_chunk_index) => target_chunk_index,
    };

    // BEWARE: MULTIPLE HACKS BELOW to get around borrowck. There has to be
    // a better way around this!

    // Temporarily remove the target chunk from the globe,
    // so that we can simultaneously write to it and read from
    // a bunch of other chunks.
    //
    // TODO: at very least avoid this most of the time by doing a read-only pass over
    // all neighbours and bailing out if we're completely up-to-date.
    let mut target_chunk = self.chunks.swap_remove(target_chunk_index);

    // Temporarily remove list of neighbours from target chunk
    // so that we can simultaneously read from it and update
    // the chunk's data.
    let mut neighbors = Vec::<super::chunk::Neighbor>::new();
    use std::mem::swap;
    swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

    // For each of this chunk's neighbors, see if we have up-to-date
    // copies of the data we share with that neighbor. Otherwise,
    // copy it over.
    for neighbor in &mut neighbors {
        let source_chunk_index = match self.index_of_chunk_at(neighbor.origin) {
            None => {
                // No worries; the chunk isn't loaded. Do nothing.
                continue;
            },
            Some(source_chunk_index) => source_chunk_index,
        };

        let source_chunk = &self.chunks[source_chunk_index];
        if neighbor.last_known_version == source_chunk.version {
            // We're already up-to-date with this neighbor's data; skip.
            continue;
        }

        // Copy over each cell, one by one.
        for target_cell_pos in &neighbor.shared_cells {
            let source_cell_pos = pos_in_owning_root(*target_cell_pos, self.spec.root_resolution);
            let source_cell =
                *source_chunk.cell(source_cell_pos);
            let target_cell =
                target_chunk.cell_mut(*target_cell_pos);
            // Copy source -> target.
            *target_cell = source_cell;
        }

        // We're now up-to-date with the neighbor.
        neighbor.last_known_version = source_chunk.version;

        // If we got this far, then it means we needed to update something.
        // So mark this chunk as having its view out-of-date.
        //
        // TODO: this all lacks subtlety; we only actually need to update the
        // destination chunk's data if the dirty cell was on the edge of
        // the chunk. This needs some thought on a good interface for mutating
        // chunks that doesn't allow oopsing this...
        target_chunk.mark_view_as_dirty();
    }

    // Put the list of neighbors back into the chunk.
    swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

    // Put the target chunk back into the world!
    self.chunks.push(target_chunk);
}
{% endhighlight %}

Note in particular: Temporarily removing the target chunk from the globe, so that we can simultaneously write to it and read from a bunch of other chunks via the chunks vector, and then putting it back into that vector at the end...

{% highlight rust %}
let mut target_chunk = self.chunks.swap_remove(target_chunk_index);

// ...

self.chunks.push(target_chunk);
{% endhighlight %}

And then between those, because I want to be able to mutate the chunk through its own functions while also iterating over a list of its neighbours, temporarily remove the list of neighbours from the struct and put it back at the end:

{% highlight rust %}
let mut neighbors = Vec::<super::chunk::Neighbor>::new();
use std::mem::swap;
swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);

// ...

swap(&mut neighbors, &mut target_chunk.authoritative_neighbors);
{% endhighlight %}

Yuck!

Ok, TODO: check out the `RefCell` approach.

What I really want, is to be able to avoid redundant index operations by doing something like https://github.com/golddranks/multi_mut provides, once the dust settles on all that undefined behaviour debate.


## What's next?

TODO:

- adding more types


As always, the source for everything I'm talking about here is up in the [_planetkit_ repository on GitHub](https://github.com/jeffparsons/planetkit).
