---
layout:     post
title:      "These weeks in PlanetKit #5: bits and bobs"
date:       2016-11-18
summary:    Finding structure, preparing for movement, and learning a lot from Yasteroids.
tags:       rust planetkit specs slog
published:  false
---

PlanetKit is a project aimed at creating a toolkit for making interactive virtual worlds. I'm writing it in the Rust programming language, which I'm finding delightful to work with, and a great fit for the task.

It's been nearly a month since I last posted here, so I'm going to drop the pretense of it being a weekly blog. The main reason it's been so long is that I've been chipping away at a few unglamorous bits and pieces. So, alas, no pretty screenshots this week.


## What have I been up to?

A lot of my commits recently have been boring housekeeping:

- Split draw code out into its own module.
- Un-bundle meshes from Pipeline State Objects so I can share the PSOs across multiple meshes. This is more efficient, because it avoids loading a new shader program if multiple meshes could re-use the same program.
- Emit a separate mesh per chunk of the world in preparation for dynamically loading/unloading chunks.
- Turn PlanetKit into a library crate. (I haven't published it on [crates.io](https://crates.io) yet.)
- Add some structured logging using the `slog` crate. [Zbigniew Siciarz recently wrote about slog](https://siciarz.net/24-days-rust-structured-logging/) in his "24 days of Rust" series.

![Structured logging using slog](/images/these-weeks-5/slog-output.png)

The more interesting changes in the mix were...

## Keep the simple case simple

One of my core philosophies going into this project has been that the simple case should be simple. Here's the `main.rs` for my example:

{% highlight rust %}
extern crate planetkit as pk;

fn main() {
    let (mut app, mut window) = pk::simple::new();
    app.run(&mut window);
}
{% endhighlight %}

The second part of that philosophy is that moving from the simple case to a more complex case should _not_ involve rewriting everything from scratch -- i.e. there is not a "quick and dirty way" and a "right way", each of which has nothing to do with the other. So obviously the above doesn't really prove anything yet. But with this token effort to keeping the simplest example extremely terse, I'm making a commitment to making it easy to start with something simple, and then slowly mutate it into whatever game you're actually trying to build, much in the spirit of video game modding scene.

This will manifest in the first couple of example games I build on top of PlanetKit. In each case I will be constantly trying to push things down into lower layers such that the code describes _only_ the things that are legitimately unique to that game.

Expect more on this as I figure out what the API should look like for things like `ExampleSimpleThing`, `ExampleComplexThing`, `ExamplePluggableThing`, etc.


## Moving to an Entity Component System, and learning from Yasteroids

As promised, I've ported what I've done so far to use the [specs ECS](https://github.com/slide-rs/specs)! Right now, I only have my rendering system and the basics of input handling hooked up, but everything else I build will be based on that start.

I was fortunate to stumble upon [Yasteroids](https://github.com/kvark/yasteroids), which also uses both _gfx_ and _specs_. So I had the great benefit of seeing how _kvark_ approached the combination.

So I took the opportunity... to Learn a lot from yasteroids: send encoders between render and main. TODO: link to yasteroids.

Yasteroids

Yasteroids is particularly interesting to me because it uses gfx and specs, both of which I'm using now for PlanetKit.

TODO: write about some of the design of how they use:

- render system
  - encoder channel
- input handling
- specs



## Movement!

I've made a token start on a component type for all entities that exist in and move between cells on a globe grid. I'm calling this a `CellDweller`. I hope the name's similarity to a certain alternative metal project doesn't create confusion.

This will be a little bit fiddly, because it means the next step is to figure out how to properly adjust the orientation of a `CellDweller` as it moves between different root quads. Recall the layout of said quads:

{% highlight plaintext %}
     ●     ●     ●     ●     ●
    / \   / \   / \   / \   / \
   /   \ /   \ /   \ /   \ /   \
  ●     ●     ●     ●     ●     ●
   \     \     \     \     \     \
    \     \     \     \     \     \
     ●     ●     ●     ●     ●     ●
      \   / \   / \   / \   / \   /
       \ /   \ /   \ /   \ /   \ /
        ●     ●     ●     ●     ●
{% endhighlight %}

As you move from one quad to the next, the change in orientation depends not just on which pair of quads you are moving between, but also where in the quad you moved from.


## What's next?

TODO

Next up I'm going to start building a simple game on top of this. Yes, that's what I said next week. I also said it'd take a little while to get started, because of the need to explore a few things. Well, I've explored them, now. Let's go!

Stay tuned for more hexagonal fun!

As always, the source for everything I'm talking about here is up in the [_planetkit_ repository on GitHub](https://github.com/jeffparsons/planetkit).
